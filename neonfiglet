#!/usr/bin/env bash
# neonfiglet: rainbow colored figlet / stdin text animation
# Copyright (C) 2025 joknarf
# License: MIT (see LICENSE file)
# Author: joknarf

lolcat() {
  awk '
    BEGIN {
      freq = 0.1
      spread = 3.0
      pi = atan2(0,-1)
      offset = 0
      theme = "rainbow"
      sat = 1.0
      light = 1.0
      pi23 = 2 * pi / 3
      pi43 = 4 * pi / 3
    }
    function adjust_saturation( gray) {
      if (sat == 1.0) return
      gray = 0.299*r + 0.587*g + 0.114*b
      r = gray + (r - gray) * sat
      g = gray + (g - gray) * sat
      b = gray + (b - gray) * sat
      if (r > 255) r = 255
      if (g > 255) g = 255
      if (b > 255) b = 255
    }
    function adjust_lightness() {
      if (light == 1.0) return
      r = r * light
      g = g * light
      b = b * light
      if (r > 255) r = 255
      if (g > 255) g = 255
      if (b > 255) b = 255
    }
    function adjust_colors() {
      adjust_saturation()
      adjust_lightness()
    }
    function rainbow(f,s,  t) {
      t = f*s
      r = sin(t) * 127 + 128
      g = sin(t + pi23) * 127 + 128
      b = sin(t + pi43) * 127 + 128
    }
    function setred(f,s) {
      rainbow(f,s)
      r=127
    }
    function setgreen(f,s) {
      rainbow(f,s)
      g=127
    }
    function setblue(f,s) {
      rainbow(f,s)
      b=127
    }
    function bw(f,s) {
      rainbow(f,s)
      g=r;b=r
    }
    function red2(f,s) {
      rainbow(f,s)
      g=255-r;b=255-r
    }
    function blue2(f,s) {
      rainbow(f,s)
      r=255-b;g=255-b
    }
    function green2(f,s) {
      rainbow(f,s)
      r=255-g;b=255-g
    }

    function grad(f,s,x1,x2,x3) {
      t= f*s
      c1 = (sin(t) + 1) / 2 * x1
      c2 = (sin(t + pi/4) + 1) / 2 * x2
      c3 = (sin(t + pi/2) + 1) / 2 * x3
    }
    function orange(f,s) {
      grad(f,s,255,150,50)
      r=c1;g=c2;b=c3
    }
    function yellow(f,s) {
      grad(f,s,255,0,100)
      r=c1;g=c1;b=c3
    }
    function magenta(f,s) {
      grad(f,s,255,0,100)
      r=c1;g=c3;b=c1
    }
    function cyan(f,s) {
      grad(f,s,255,0,100)
      r=c3;g=c1;b=c1
    }
    function blue(f,s) {
      grad(f,s,255,0,100)
      r=c3;g=c3;b=c1
    }
    function green(f,s) {
      grad(f,s,255,0,100)
      r=c3;g=c1;b=c3
    }
    function red(f,s) {
      grad(f,s,255,0,100)
      r= c1;g=c3;b=c3
    }
    function gradient(f,s,  t) {
      t = f*s
      r = (sin(t + 0) + 1) / 2 * 255
      g = (sin(t + pi/3) + 1) / 2 * 255
      b = (sin(t + 2*pi/3) + 1) / 2 * 255
    }
    function pastel(f,s) {
      t = f*s
      r = (sin(t) + 1) / 2 * 155 + 100
      g = (sin(t + pi23) + 1) / 2 * 155 + 100
      b = (sin(t + pi43) + 1) / 2 * 155 + 100
    }
    # metallic bluish/grey gradient with minimal red/green visibility
    function metal(f,s,  t,x,w,hf, r1,g1,b1, r2,g2,b2, r3,g3,b3)
    {
      t = f*s
      # smooth parameter in [0..1]
      x = (sin(t) + 1) / 2

      # three control colors (dark gray -> steel-blue -> almost-white)
      r1=90;  g1=95;  b1=100   # dark gray
      r2=80;  g2=120; b2=200   # steel blue
      r3=220; g3=230; b3=255   # bright white/blue

      if (x < 0.5) {
        w = x * 2
        r = r1*(1-w) + r2*w
        g = g1*(1-w) + g2*w
        b = b1*(1-w) + b2*w
      } else {
        w = (x - 0.5) * 2
        r = r2*(1-w) + r3*w
        g = g2*(1-w) + g3*w
        b = b2*(1-w) + b3*w
      }

      # clamp and return
      if (r<0) r=0; if (r>255) r=255
      if (g<0) g=0; if (g>255) g=255
      if (b<0) b=0; if (b>255) b=255
    }
    {
        nchars = split($0, chars, "")
        for(i=1; i<=nchars; i++) {
          if (chars[i] == " ") printf(" ")
          else {
            @theme(freq, offset+i/spread)
            adjust_colors()
            printf("\033[38;2;%d;%d;%dm%s", r, g, b, chars[i])
          }
        }
        offset += spread
        printf("\n")
    }
    END {
      printf("\033[39m")
    }' "$@"
}
lolc() {
  lolcat freq=0.15 spread=2.0 offset=$off "$@"
}
s2cs() {
  cs=$(LANG=C;printf '%.2f' "$1")
  cs="${cs/[.]/}"
  cs=$((10#$cs))
}

now() {
  typeset cs
  now="${EPOCHREALTIME/,/.}"
  [ "$now" ] || read -r now _ 2>/dev/null </proc/uptime
  [ "$now" ] || now=$SECONDS
  s2cs "$now"; now="$cs"
}

right_pad_lines() {
  local s i 
  max=0
  for s in "${lines[@]}"; do (( ${#s} > max )) && max=${#s}; done
  for i in "${!lines[@]}"; do 
    printf -v sp '%*s' $((max-${#lines[i]})) ''
    lines[i]="${lines[i]}$sp"
  done
}

align_center() {
  nspaces=$(((width-$max)/2))          # center align
  printf -v spaces '%*s' $nspaces ''  # prefix spaces
  lines=( "${lines[@]/#/$spaces}" )   # add spaces  
}

align_right() {
  nspaces=$((width-$max))             # right align
  printf -v spaces '%*s' $nspaces ''  # prefix spaces
  lines=( "${lines[@]/#/$spaces}" )   # add spaces  
}

do_scroll_down() {
  printf '\n%.0s' $(eval echo "{1..$len}")
  tput cuu $len
  for ((i=1;i<=$len;i++)) ;do
    printf "%s\n" "${lines[@]:$((len-i))}" |lolc "$@"
    off+=$offinc
    tput cuu $i
    sleep $delay
  done
}

do_scroll_up() {
  printf '\n%.0s' $(eval echo "{1..$len}")
  for ((i=1;i<=$len;i++)) ;do
    tput cuu $i
    printf "%s\n" "${lines[@]:0:$i}" |lolc "$@"
    off+=$offinc
    sleep $delay
  done
  tput cuu $len
}

# Column-by-column staggered reveal during scroll-up
# Character at (row r, col c) is shown when frame >= c + r + 1
# First column appears top->bottom, second column starts when first column reaches second row, etc.
do_scroll_up2() {
  typeset sl group_size vis_cols ngroups total max_p pc c p start k line
  min_lspaces
  printf '\n%.0s' $(eval echo "{1..$len}")
  sl=${#lines[0]}
  # prefix with min spaces to keep alignment while skipping those columns
  printf -v minsp '%*s' "$min" ''
  # group columns in batches
  group_size=8
  vis_cols=$((sl - min))
  ngroups=$(((vis_cols + group_size - 1) / group_size))
  total=$((ngroups + len - 1))

  # precompute column strings and group index per column
  typeset -a col col_group
  for ((c=0;c<sl;c++)); do
    s=""
    for ((r=0;r<len;r++)); do
      s+="${lines[r]:c:1}"
    done
    col[c]="$s"
    if [ $c -lt $min ]; then
      col_group[c]=-1
    else
      col_group[c]=$(((c - min) / group_size))
    fi
  done

  for ((frame=0; frame<total; frame++)); do
    # compute visible counts per column p_c based on precomputed group index
    max_p=0
    for ((c=$min;c<sl;c++)); do
      p=$((frame - col_group[c] + 1))
      [ $p -gt $len ] && p=$len
      pc[c]=$p
      [ $p -gt $max_p ] && max_p=$p
    done

    # render block of len rows (bottom-align each column's visible chars)
    tput cuu $len
    for ((r=0; r<len; r++)); do
      line="$minsp"
      for ((c=min; c<sl; c++)); do
        p=${pc[c]}
        start=$((len - p))
        k=$((r - start))
        [ $k -ge 0 -a $k -lt $p ] && line+="${lines[k]:c:1}" || line+=" "
      done
      printf '%s\n' "$line"
    done | lolc "$@"
    off+=$offinc
    sleep $delay
  done
  tput cuu $len
}

do_scroll_right() {
  for ((pos=${#lines[0]}-7;pos>=0;pos-=8));do
    printf -v chars '%*s' $pos ''
    chars=${chars// /?}
    printf "%s\n" "${lines[@]/#$chars/}" |lolc "$@"
    off+=$offinc
    tput cuu $len
    sleep $delay
  done
}

min_lspaces() {
  typeset s lspaces nspaces
  min=$width
  for s in "${lines[@]}";do
    lspaces="${s%%[^ ]*}"
    nspaces=${#lspaces}
    (( $nspaces < $min )) && min=$nspaces
  done
}

do_scroll_left() {
  min_lspaces
  # right pad lines
  d=$((width-${#lines[0]}))
  printf -v rspaces '%*s' $d ''
  lines=( "${lines[@]/%/$rspaces}" )
  for ((pos=width-min;pos>=0;pos-=8));do
    printf -v spaces '%*s' $pos ''
    l=("${lines[@]/#/$spaces}")
    chars=${spaces// /?}
    printf "%s\n" "${l[@]/%$chars/}" |lolc "$@"
    off+=$offinc
    tput cuu $len
    sleep $delay
  done
}

do_write() {
  min_lspaces
  for ((pos=${#lines[0]}-$min;pos>=0;pos-=8));do
    printf -v chars '%*s' $pos ''
    chars=${chars// /?}
    printf "%s\n" "${lines[@]/%$chars/}" |lolc "$@"
    off+=$offinc
    tput cuu $len
    sleep $delay
  done
}

# bash <4
type mapfile >/dev/null 2>&1 || mapfile() {
  typeset o="$IFS"
  # disable globbing to prevent filenames expansion
  IFS=$'\n'; set -f; lines=( $(< /dev/stdin) ); set +f; IFS="$o"
}

do_anim() {
  typeset lines twidth nspaces spaces timeout="$1" delay="$2" cs
  typeset -i off=$RANDOM
  s2cs "$timeout"; timeout="$cs"
  s2cs "$delay"; timeout=$((timeout-cs))
  shift 2
  mapfile -t lines                    # put text from stdin into array
  right_pad_lines
  $center && align_center
  $right && align_right
  len="${#lines[@]}"
  trap 'tput cud $len;exit' INT # move cursor to bottom left
  stty -echo </dev/tty            # disable echo
  tput civis                          # hide cursor
  now; stime=$now
  end=$(($stime+$timeout))
  case "$scroll" in
    u|up) do_scroll_up "$@";;
    U|stagger) do_scroll_up2 "$@";;
    d|down) do_scroll_down "$@";;
    r|right) do_scroll_right "$@";;
    l|left) do_scroll_left "$@";;
    w|write) do_write "$@";;
  esac
  printf '%s\n' "${lines[@]}" |lolc "$@"
  off+=$offinc
  now
  while [ $now -lt $end ];do       # anim colors changing rainbow offset
    sleep $delay
    tput cuu $len              # cursor up nb logo lines
    printf '%s\n' "${lines[@]}" |lolc "$@"
    off+=$offinc
    now
  done
}

usage() {
  center=false
  offinc="-2"
  echo "usage: ${0##*/} [-t <tmoutsec>] [-s <sleepsec>] [-S <dir>] [-F] [figletopts] [<message>] [lolcatopts]

    -S <dir>       : initial scroll direction (u, U, d, l, r, u2, write, none)
    -F             : display <message> with all fonts in <fontdir>
    -t <tmoutsec>  : animation duration (default 2.0)
    -s <sleepsec>  : sleep between frales (default 0.07)
    -o <offsetinc> : rainbow anim offset increment (default 5)
    <message>      : message to display (if not uses stdin w/o figlet)
    figletopts:
      -l|-r : left / right align (default center)
      -d <fontdir> : font directory
      -f <font> : font name
    lolcatopts:
      spread=<spread> : default 2.0
      freq=<freq>     : default 0.15
      light=<val>     : lightness multiplier default 1.0
      sat=<val>       : saturation multiplier default 1.0
      theme=<name>    : color theme (rainbow, gradient, pastel, metal, bw, red, green, blue, orange,
                        yellow, magenta, cyan, setred, setgreen, setblue, red2, green2, blue2)
                        default rainbow
" | fold -w $width| do_anim 0.5 0.01
  exit 1
}  
_stty_ori=$(stty -g </dev/tty)  # save stty settings)
trap 'stty $_stty_ori </dev/tty;tput cnorm' EXIT              # restore cursor at exit
timeout=2.0
delay=0.07
allfonts=false
scroll=u
width=$(tput cols)
figargs=()
center=true
right=false
offinc="-5"
while getopts ":t:s:d:f:lrS:Fo:h" opt; do
  case "$opt" in
    t) timeout="$OPTARG";;
    s) delay="$OPTARG";;
    l) figargs+=("-$opt");center=false;;
    r) figargs+=("-$opt");center=false;right=true;;
    o) offinc="-$OPTARG";;
    F) allfonts=true;;
    S) scroll="$OPTARG";;
    f|d) figargs+=(-"$opt" "$OPTARG");fontdir="$OPTARG";;
    h) usage;;
    :) echo "Option -$OPTARG requires an argument"; usage ;;
    \?) echo "Invalid option: -$OPTARG"; usage;;
  esac
done

shift $((OPTIND - 1))
text="$1"
shift
$allfonts && {
  : "${fontdir:=$(figlet -I2 2>/dev/null)}"
  center=false
  right=false
  cd "$fontdir"
  for i in $(ls *.?lf */*.?lf 2>/dev/null);do
    font=${i%.*}
    echo $font":"
    font=${font##*/}
    figlet -c -w $width "${figargs[@]}" -f "$i" "${text:-${font^} 123}" |do_anim $timeout $delay "$@"
  done
  exit
}
if [ "$text" ] ;then
  center=false # done by figlet
  right=false
  ! type figlet >/dev/null 2>&1 && do_anim $timeout $delay "$@" <<<"$text" && exit
  figlet -c -w $width "${figargs[@]}" "$text" |do_anim $timeout $delay "$@"
else
  printf '\033[?7l'    # disable line wrapping
  do_anim $timeout $delay "$@"
  printf '\033[?7h'    # enable line wrapping
fi
