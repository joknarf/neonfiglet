#!/usr/bin/env bash
# neonfiglet: rainbow colored figlet / stdin text animation
# Copyright (C) 2025 joknarf
# License: MIT (see LICENSE file)
# Author: joknarf
awk=awk
type gawk >/dev/null 2>&1 && awk=gawk
type mawk >/dev/null 2>&1 && mawk=gawk

sleep() {
  read -rs -t $1 -u 2
}
_tput() {
  case "$1" in
    # -------- Cursor movement --------
    cuu) printf '\e[%dA' "${2:-1}" ;;
    cud) printf '\e[%dB' "${2:-1}" ;;
    # -------- Cursor visibility --------
    civis) printf '\e[?25l' ;;
    cnorm) printf '\e[?25h' ;;
    lines)
      [ ! "$LINES" ] && LINES=$(stty size) && LINES=${LINES% *}
      printf '%s\n' "${LINES:-24}"
      ;;
    cols)
      [ ! "$COLUMNS" ] && COLUMNS=$(stty size) && COLUMNS=${COLUMNS#* }
      printf '%s\n' "${COLUMNS:-80}"
      ;;
  esac
}
lolcat() {
  $awk '
    BEGIN {
      freq = 0.1
      spread = 3.0
      offset = 0
      sat = 1.0
      light = 1.0
      pi = atan2(0,-1)
      pi23 = 2 * pi / 3
      pi43 = 4 * pi / 3
    }
    function adjust_saturation( gray) {
      if (sat == 1.0) return
      gray = 0.299*r + 0.587*g + 0.114*b
      r = gray + (r - gray) * sat
      g = gray + (g - gray) * sat
      b = gray + (b - gray) * sat
      if (r > 255) r = 255
      if (g > 255) g = 255
      if (b > 255) b = 255
    }
    function adjust_lightness() {
      if (light == 1.0) return
      r = r * light
      g = g * light
      b = b * light
      if (r > 255) r = 255
      if (g > 255) g = 255
      if (b > 255) b = 255
    }
    function adjust_colors() {
      adjust_saturation()
      adjust_lightness()
    }
    function rainbow(f,s,  t) {
      t = f*s
      r = sin(t) * 127 + 128
      g = sin(t + pi23) * 127 + 128
      b = sin(t + pi43) * 127 + 128
    }
    function setred(f,s) {
      rainbow(f,s)
      r=127
    }
    function setgreen(f,s) {
      rainbow(f,s)
      g=127
    }
    function setblue(f,s) {
      rainbow(f,s)
      b=127
    }
    function bw(f,s) {
      rainbow(f,s)
      g=r;b=r
    }
    function red2(f,s) {
      rainbow(f,s)
      g=255-r;b=255-r
    }
    function blue2(f,s) {
      rainbow(f,s)
      r=255-b;g=255-b
    }
    function green2(f,s) {
      rainbow(f,s)
      r=255-g;b=255-g
    }

    function grad(f,s,x1,x2,x3) {
      t= f*s
      c1 = (sin(t) + 1) / 2 * x1
      c2 = (sin(t + pi/4) + 1) / 2 * x2
      c3 = (sin(t + pi/2) + 1) / 2 * x3
    }
    function orange(f,s) {
      grad(f,s,255,150,50)
      r=c1;g=c2;b=c3
    }
    function yellow(f,s) {
      grad(f,s,255,0,100)
      r=c1;g=c1;b=c3
    }
    function magenta(f,s) {
      grad(f,s,255,0,100)
      r=c1;g=c3;b=c1
    }
    function cyan(f,s) {
      grad(f,s,255,0,100)
      r=c3;g=c1;b=c1
    }
    function blue(f,s) {
      grad(f,s,255,0,100)
      r=c3;g=c3;b=c1
    }
    function green(f,s) {
      grad(f,s,255,0,100)
      r=c3;g=c1;b=c3
    }
    function red(f,s) {
      grad(f,s,255,0,100)
      r= c1;g=c3;b=c3
    }
    function gradient(f,s,  t) {
      t = f*s
      r = (sin(t + 0) + 1) / 2 * 255
      g = (sin(t + pi/3) + 1) / 2 * 255
      b = (sin(t + 2*pi/3) + 1) / 2 * 255
    }
    function pastel(f,s) {
      t = f*s
      r = (sin(t) + 1) / 2 * 155 + 100
      g = (sin(t + pi23) + 1) / 2 * 155 + 100
      b = (sin(t + pi43) + 1) / 2 * 155 + 100
    }
    # metallic bluish/grey gradient with minimal red/green visibility
    function metal(f,s,  t,x,w,hf, r1,g1,b1, r2,g2,b2, r3,g3,b3)
    {
      t = f*s
      # smooth parameter in [0..1]
      x = (sin(t) + 1) / 2

      # three control colors (dark gray -> steel-blue -> almost-white)
      r1=90;  g1=95;  b1=100   # dark gray
      r2=80;  g2=120; b2=200   # steel blue
      r3=220; g3=230; b3=255   # bright white/blue

      if (x < 0.5) {
        w = x * 2
        r = r1*(1-w) + r2*w
        g = g1*(1-w) + g2*w
        b = b1*(1-w) + b2*w
      } else {
        w = (x - 0.5) * 2
        r = r2*(1-w) + r3*w
        g = g2*(1-w) + g3*w
        b = b2*(1-w) + b3*w
      }

      # clamp and return
      if (r<0) r=0; if (r>255) r=255
      if (g<0) g=0; if (g>255) g=255
      if (b<0) b=0; if (b>255) b=255
    }
    {
        nchars = split($0, chars, "")
        for(i=1; i<=nchars; i++) {
          if (chars[i] == " ") printf(" ")
          else {
            '$theme'(freq, offset+i/spread)
            adjust_colors()
            printf("\033[38;2;%d;%d;%dm%s", r, g, b, chars[i])
          }
        }
        offset += spread
        printf("\n")
    }
    END {
      printf("\033[39m")
    }' "$@"
}

lolc() {
  lolcat freq=0.15 spread=2.0 offset=$off "$@"
}

s2cs() {
  cs=$(LANG=C;printf '%.2f' "$1")
  cs="${cs/[.]/}"
  cs=$((10#$cs))
}

now() {
  typeset cs
  now="${EPOCHREALTIME/,/.}"
  [ "$now" ] || read -r now _ 2>/dev/null </proc/uptime
  [ "$now" ] || now=$SECONDS
  s2cs "$now"; now="$cs"
}

right_pad_lines() {
  local s i
  max=0
  for s in "${lines[@]}"; do (( ${#s} > max )) && max=${#s}; done
  for i in "${!lines[@]}"; do 
    printf -v sp '%*s' $((max-${#lines[i]})) ''
    lines[i]="${lines[i]}$sp"
  done
}

align_center() {
  nspaces=$(((width-$max)/2))         # center align
  printf -v spaces '%*s' $nspaces ''  # prefix spaces
  lines=( "${lines[@]/#/$spaces}" )   # add spaces  
}

align_right() {
  nspaces=$((width-$max))             # right align
  printf -v spaces '%*s' $nspaces ''  # prefix spaces
  lines=( "${lines[@]/#/$spaces}" )   # add spaces  
}

print_cr() {
  printf -v spaces '%*s' $1 ''
  printf '%s' "${spaces// /$'\n'}"
}

do_scroll_down() {
  print_cr $len
  _tput cuu $len
  for ((i=1;i<=$len;i++)) ;do
    printf "%s\n" "${lines[@]:$((len-i))}" |lolc "$@"
    off+=$offinc
    _tput cuu $i
    sleep $delay
  done
}

do_scroll_up() {
  print_cr $len
  for ((i=1;i<=$len;i++)) ;do
    _tput cuu $i
    printf "%s\n" "${lines[@]:0:$i}" |lolc "$@"
    off+=$offinc
    sleep $delay
  done
  _tput cuu $len
}

# Column-by-column staggered reveal during scroll-up
# First column appears top->bottom, second column starts when first column reaches second row, etc.
do_scroll_up2() {
  typeset sl group_size ngroups total pc c p start k line
  print_cr $len
  # skip left spaces
  min_lspaces
  printf -v minsp '%*s' "$min" ''
  group_size=8
  sl=${#lines[0]}
  ngroups=$(((sl - min + group_size - 1) / group_size))
  total=$((ngroups + len - 1))

  for ((frame=0; frame<total; frame++)); do
    _tput cuu $len
    for ((r=0; r<len; r++)); do
      line="$minsp"
      for ((c=min; c<sl; c++)); do
        p=$((frame - (c-min)/group_size + 1))
        [ $p -gt $len ] && p=$len
        k=$((r - len + p))
        [ $k -ge 0 -a $k -lt $p ] && line+="${lines[k]:c:1}" || line+=" "
      done
      printf '%s\n' "$line"
    done | lolc "$@"
    off+=$offinc
    sleep $delay
  done
  _tput cuu $len
}

do_scroll_right() {
  for ((pos=${#lines[0]}-7;pos>=0;pos-=8));do
    printf -v chars '%*s' $pos ''
    chars=${chars// /?}
    printf "%s\n" "${lines[@]/#$chars/}" |lolc "$@"
    off+=$offinc
    _tput cuu $len
    sleep $delay
  done
}

min_lspaces() {
  typeset s lspaces nspaces
  min=$width
  for s in "${lines[@]}";do
    lspaces="${s%%[^ ]*}"
    nspaces=${#lspaces}
    (( $nspaces < $min )) && min=$nspaces
  done
}

do_scroll_left() {
  min_lspaces
  # right pad lines
  d=$((width-${#lines[0]}))
  printf -v rspaces '%*s' $d ''
  lines=( "${lines[@]/%/$rspaces}" )
  for ((pos=width-min;pos>=0;pos-=8));do
    printf -v spaces '%*s' $pos ''
    l=("${lines[@]/#/$spaces}")
    chars=${spaces// /?}
    printf "%s\n" "${l[@]/%$chars/}" |lolc "$@"
    off+=$offinc
    _tput cuu $len
    sleep $delay
  done
}

do_write() {
  min_lspaces
  for ((pos=${#lines[0]}-$min;pos>=0;pos-=8));do
    printf -v chars '%*s' $pos ''
    chars=${chars// /?}
    printf "%s\n" "${lines[@]/%$chars/}" |lolc "$@"
    off+=$offinc
    _tput cuu $len
    sleep $delay
  done
}

# bash <4
type mapfile >/dev/null 2>&1 || mapfile() {
  typeset o="$IFS"
  # disable globbing to prevent filenames expansion
  IFS=$'\n'; set -f; lines=( $(< /dev/stdin) ); set +f; IFS="$o"
}

do_anim() {
  typeset lines twidth nspaces spaces timeout="$1" delay="$2" cs
  typeset -i off=$RANDOM
  s2cs "$timeout"; timeout="$cs"
  s2cs "$delay"; timeout=$((timeout-cs))
  shift 2
  mapfile -t lines              # put text from stdin into array
  $msg && lines=( "${prefix[@]}" "${lines[@]}" "${suffix[@]}" )
  right_pad_lines

  $center && align_center
  $right && align_right
  len="${#lines[@]}"
  trap '_tput cud $len;exit' INT # move cursor to bottom left
  stty -echo </dev/tty          # disable echo
  _tput civis                    # hide cursor
  now
  end=$(($now+$timeout))
  case "$scroll" in
    u|up) do_scroll_up "$@";;
    U|stagger) do_scroll_up2 "$@";;
    d|down) do_scroll_down "$@";;
    r|right) do_scroll_right "$@";;
    l|left) do_scroll_left "$@";;
    w|write) do_write "$@";;
  esac
  printf '%s\n' "${lines[@]}" |lolc "$@"
  off+=$offinc
  now
  while [ $now -lt $end ];do   # anim colors changing rainbow offset
    sleep $delay
    _tput cuu $len              # cursor up nb logo lines
    printf '%s\n' "${lines[@]}" |lolc "$@"
    off+=$offinc
    now
  done
}

do_msg() {
  mapfile -t lines <<'EOF'
       \\\||||||////           
        \\  ~ ~  //            
         (  @ @  )             
______ oOOo-(_)-oOOo___________
                               
EOF
  max=${#lines[0]}
  $right && align_right
  $center && align_center
  prefix=( "${lines[@]}" )
  mapfile -t lines <<'EOF'
_____________Oooo._____________
   .oooO     (   )             
    (   )     ) /              
     \ (     (_/               
      \_)                      
EOF
  $right && align_right
  $center && align_center
  suffix=( "${lines[@]}" )
}
usage() {
  center=false
  offinc="-2"
  theme='rainbow'
  echo "usage: ${0##*/} [-t <tmoutsec>] [-s <sleepsec>] [-S <dir>] [-F] [figletopts] [<message>] [lolcatopts]

    -S <dir>       : initial scroll direction (u, U, d, l, r, u2, write, none)
    -F             : display <message> with all fonts in <fontdir>
    -t <tmoutsec>  : animation duration (default 2.0)
    -s <sleepsec>  : sleep between frames (default 0.07)
    -o <offsetinc> : rainbow anim offset increment (default 5)
    -m             : display figlet message with classic Barefoot Guy
    <message>      : message to display (if not uses stdin w/o figlet)
    figletopts:
      -l|-r : left / right align (default center)
      -d <fontdir> : font directory
      -f <font> : font name
    lolcatopts:
      spread=<spread> : default 2.0
      freq=<freq>     : default 0.15
      light=<val>     : lightness multiplier default 1.0
      sat=<val>       : saturation multiplier default 1.0
      theme=<name>    : color theme (rainbow, gradient, pastel, metal, bw, red, green, blue, orange,
                        yellow, magenta, cyan, setred, setgreen, setblue, red2, green2, blue2)
                        default rainbow
" | fold -w $width| do_anim 0.5 0.01
  exit 1
}  
_stty_ori=$(stty -g </dev/tty)  # save stty settings
trap 'stty $_stty_ori </dev/tty;_tput cnorm' EXIT   # restore cursor/tty at exit
timeout=2.0
delay=0.07
allfonts=false
scroll=u
width=$(_tput cols)
figargs=()
center=true
right=false
offinc="-5"
msg=false
theme='rainbow'
while getopts ":t:s:d:f:lrS:Fo:hm" opt; do
  case "$opt" in
    t) timeout="$OPTARG";;
    s) delay="$OPTARG";;
    l) figargs+=("-$opt");center=false;;
    r) figargs+=("-$opt");center=false;right=true;;
    o) offinc="-$OPTARG";;
    F) allfonts=true;;
    S) scroll="$OPTARG";;
    f|d) figargs+=(-"$opt" "$OPTARG");fontdir="$OPTARG";;
    m) msg=true;;
    h) usage;;
    :) echo "Option -$OPTARG requires an argument"; usage ;;
    \?) echo "Invalid option: -$OPTARG"; usage;;
  esac
done
shift $((OPTIND - 1))
text="$1"
[ "$text" = '-' ] && text=''
shift
themes=(
  rainbow gradient pastel metal
  red green blue orange yellow magenta cyan
  setred setgreen setblue red2 green2 blue2 bw
)
themes=" ${themes[*]} "
for opt in "$@";do
  case "$opt" in
    theme=*) theme="${opt#theme=}"
      [ "${themes/ $theme /}" = "$themes" ] && echo "unknown theme: $theme" && usage;;
    sat=[0-9]*|light=[0-9]*|spread=[0-9]*|freq=[0-9]*|offset=[0-9]*) ;;
    *) echo "invalid lolcat option: $opt"; usage;;
  esac
done
$allfonts && {
  : "${fontdir:=$(figlet -I2 2>/dev/null)}"
  center=false
  right=false
  cd "$fontdir"
  trap 'exit 130' INT
  for i in $(ls *.?lf */*.?lf 2>/dev/null);do
    font=${i%.*}
    echo $font":"
    font=${font##*/}
    figlet -c -w $width "${figargs[@]}" -f "$i" "${text:-${font^} 123}" |do_anim $timeout $delay "$@"
  done
  exit
}
$msg && do_msg
if [ "$text" ] ;then
  center=false # done by figlet
  right=false
  ! type figlet >/dev/null 2>&1 && do_anim $timeout $delay "$@" <<<"$text" && exit
  figlet -c -w $width "${figargs[@]}" "$text" |do_anim $timeout $delay "$@"
else
  printf '\033[?7l'    # disable line wrapping
  do_anim $timeout $delay "$@"
  printf '\033[?7h'    # enable line wrapping
fi
